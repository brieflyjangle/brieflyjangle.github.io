<!DOCTYPE html>
<html lang="en">

<head>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		splaytree_search_system_analysis_report | 
	 
	Huiwen Learning Notes
	</title>
	
	<!-- keywords,description -->
	
	

	<!-- favicon -->
	


	<!-- search -->
	<script>
		var searchEngine = "";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.0/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>


	
	

<meta name="generator" content="Hexo 7.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="stylesheet" href="/css/prism-dracula.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><header id="header">
    <a id="title" href="/" class="logo">Huiwen Learning Notes</a>

	<ul id="menu">
    

    

    

    
  
    
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="Press Enter to search">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										computer_arch
									</a>
									
							<ul>
								<li class="file">
									<a href="/computer_arch/Chap1-fundamental-quantitative-design-n-analysis/">
                     
										    Chap1-fundamental-quantitative-design-n-analysis
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										data_str_and_algo
									</a>
									
							<ul>
								<li class="file">
									<a href="/data_str_and_algo/adv-bin-search-tree/">
                     
										    adv-bin-search-tree
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/data_str_and_algo/bin_search_tree/">
                     
										    bin_search_tree
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/data_str_and_algo/splaytree-search-system-analysis-report/">
                     
										    splaytree-search-system-analysis-report
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/data_str_and_algo/stack/">
                     
										    stack
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										other
									</a>
									
							<ul>
								<li class="file">
									<a href="/other/how-to-start-personal-blog/">
                     
										    how-to-start-personal-blog
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content" class="content">
		<h1 id="article-title">
	splaytree_search_system_analysis_report
</h1>

<!-- meta -->
<div class="article-meta">
	

	<span>HuiWen</span>
	<span>2024-12-08 13:07:47</span>

  <div id="article-categories">
    
		  <span>Categories：</span>
      
    

    
		    <span>Tags：</span>
        
    
  </div>

</div>

<!-- content -->
<div id="article-content">
	<h2 id="Part-1-Introduction">Part 1: Introduction</h2>
<h3 id="1-1-Synopsis-Project">1.1 Synopsis Project</h3>
<p>A Splay Tree Student Record Disciplinary System is a data structure-based application designed to efficiently manage, search, and manipulate student disciplinary records. Using a splay tree, the system organizes data to ensure that frequently accessed records are quickly retrievable, making it suitable for dynamic environments such as schools and colleges.</p>
<p>The system maintains student details, including a unique student ID, name, class, and disciplinary records. Each operation, such as searching, inserting, or deleting records, triggers a splay operation to reorganize the tree, ensuring the accessed node moves closer to the root. This property improves performance over time as commonly accessed records become faster to retrieve.</p>
<h3 id="1-2-Objective-of-the-Project">1.2 Objective of the Project</h3>
<ol>
<li>
<p><strong>Efficient Record Management:</strong><br>
To store and manage student disciplinary records with high performance, especially for frequent search and update operations.</p>
</li>
<li>
<p><strong>Optimized Searching:</strong><br>
To enable quick retrieval of student records using splay tree properties, making recently or frequently accessed records easier to locate.</p>
</li>
<li>
<p><strong>Dynamic Data Handling:</strong><br>
To handle real-time updates, such as adding new records, modifying existing ones, or deleting outdated entries, without compromising search efficiency.</p>
</li>
<li>
<p><strong>Cost-Effective Maintenance:</strong><br>
To provide a self-adjusting structure that avoids the need for manual rebalancing or periodic reorganization of the tree.</p>
</li>
<li>
<p><strong>Adaptability:</strong><br>
To allow customization for different educational institutions, supporting additional attributes or modifications in disciplinary records as needed.</p>
</li>
<li>
<p><strong>Real-Time Feedback:</strong><br>
To provide real-time performance improvement through splay operations, ensuring efficient response times even as the data size grows.</p>
</li>
<li>
<p><strong>Scalability:</strong><br>
To handle a large number of student records (e.g., thousands of records) while maintaining optimal performance.</p>
</li>
</ol>
<hr>
<h2 id="Part-2-System-Analysis-And-Design-Use-case-Flowchart-and-Class-Diagram">Part 2: System Analysis And Design (Use case, Flowchart, and Class Diagram)</h2>
<h3 id="2-1-System-Requirements">2.1 System Requirements</h3>
<p>Use case diagram - Describe the user of the system and details description of each case</p>
<pre class="mermaid">sequenceDiagram
    Teacher->>Database: search, insert, delete
    Parent->>Database: search 
    Student->>Database: search</pre>
<p>=======-</p>
<h4 id="Details-description-for-each-use-cases-in-Student-Disciplinary-Record-System">Details description for each use cases in Student Disciplinary Record System</h4>
<h4 id="Use-Case-1-Search">==Use Case 1: Search==</h4>
<p>Searching system is using <code>search_splaytree</code> function dynamically selects the traversal method (preorder, inorder, or postorder) based on the value of traversal_type.</p>
<ol>
<li>Input Parameters of the <code>search_splaytree</code></li>
</ol>
<pre class="language-c" data-language="c"><code class="language-c">Node* search_splaytree(SplayTree* tree, const char* key, const char* traversal_type)</code></pre>
<ul>
<li><strong><code>tree</code></strong>: Pointer to the splay tree in which the search is performed.</li>
<li><strong><code>key</code></strong>: The key (unique identifier) of the node you want to find.</li>
<li><strong><code>traversal_type</code></strong>: A string that specifies the traversal method.</li>
<li>Case Statement for <strong>traversal type</strong>.<pre class="language-c" data-language="c"><code class="language-c">switch (traversal_type[0])
- case &#96;&#39;p&#39;&#96; for preordr
- case &#96;&#39;i&#39;&#96; for inorder
- case &#96;&#39;o&#39;&#96; for postorder</code></pre>
</li>
<li>The function examines the first character of the <code>traversal_type</code> string (<code>traversal_type[0]</code>).</li>
<li>Depending on its value, it calls the appropriate traversal-based search function.</li>
</ul>
<ol start="2">
<li>Traversal Type 1: Preorder Traversal</li>
</ol>
<ul>
<li><code>Preorder_search</code> function traverses the tree in <strong>Root → Left → Right</strong> order and searches for a node with the given <code>key</code>.</li>
<li>Preorder traversal is used for general searches (like when inserting).</li>
<li>For a binary tree:<pre class="language-none"><code class="language-none">    A
   &#x2F; \
  B   C
 &#x2F; \
D   E</code></pre>
</li>
<li>Preorder Traversal: <code>A B D E C</code></li>
</ul>
<ol start="3">
<li>Traversal Type 2: Inorder Traversal</li>
</ol>
<ul>
<li><code>Inorder traversal</code> visits nodes in <strong>Left → Root → Right</strong> order.</li>
<li>While not typically used for key-based searches in a binary search tree, it can be helpful for operations requiring sorted order traversal.</li>
<li>For a binary tree:  <pre class="language-none"><code class="language-none">  A
 &#x2F; \
 B   C
&#x2F; \
D   E</code></pre>
</li>
<li>Inorder Traversal: <code>D B E A C</code></li>
</ul>
<ol start="4">
<li>Traversal Type 3: Postorder Traversal</li>
</ol>
<ul>
<li>
<p><code>Postorder traversal</code> follows the order <strong>Left → Right → Root</strong> order.</p>
</li>
<li>
<p>It’s often used in tree deletion processes, as it processes child nodes before the root.</p>
</li>
<li>
<p>For a binary tree:</p>
  <pre class="language-none"><code class="language-none">    A
   &#x2F; \
  B   C
 &#x2F; \
D   E</code></pre>
</li>
<li>
<p>Postorder Traversal: <code>D E B C A</code></p>
</li>
</ul>
<ol start="5">
<li>How <code>search_splaytree</code> function works
<ol>
<li>Based on the provided <code>traversal_type</code>, the function determines which traversal to use.</li>
<li>The corresponding traversal search function is invoked to locate the node with the given <code>key</code>.</li>
<li>If the traversal type is invalid, the function gracefully handles it and returns <code>NULL</code>.</li>
</ol>
</li>
</ol>
<h4 id="Use-Case-2-Insert">==Use Case 2: Insert==</h4>
<p><code>insert_splaytree</code> function attempts to insert a new node with the given id, name, class, and record into the splay tree. If a node with the same id already exists, it prevents duplication.</p>
<ol>
<li>Search for an Existing Node<pre class="language-c" data-language="c"><code class="language-c">current &#x3D; search_splaytree(tree, id, &quot;preorder&quot;);  &#x2F;&#x2F; Search for the node before insertion</code></pre>
</li>
</ol>
<ul>
<li>The <code>search_splaytree</code> function is called to check if a node with the given <code>id</code> already exists in the tree.</li>
<li>It uses the “preorder” traversal method for searching (though typically, splay trees are searched based on key comparison without traversals).</li>
<li>If a node is found (<code>current != NULL</code>), the function prevents duplicate insertion and exits early.</li>
</ul>
<ol start="2">
<li>Create and Insert a New Node<pre class="language-c" data-language="c"><code class="language-c">if (current &#x3D;&#x3D; NULL) &#123;
    Node* newNode &#x3D; create_node(id, name, class, record); </code></pre>
</li>
</ol>
<ul>
<li>
<p>If no node with the same <code>id</code> exists, a new node is created using the <code>create_node</code> function, which allocates memory for a new <code>Node</code> and initializes its attributes.</p>
<ul>
<li>Case 1: Tree is Empty</li>
</ul>
 <pre class="language-c" data-language="c"><code class="language-c">if (tree-&gt;root &#x3D;&#x3D; NULL) &#123;
   &#x2F;&#x2F; Tree is empty, new node becomes root
   tree-&gt;root &#x3D; newNode;
&#125;</code></pre>
</li>
<li>
<p>If the tree is empty (<code>tree-&gt;root == NULL</code>), the new node is set as the root of the tree.</p>
<ul>
<li>Case 2: Tree is Non-Empty</li>
</ul>
 <pre class="language-c" data-language="c"><code class="language-c">else &#123;
    &#x2F;&#x2F; Otherwise, find the parent node
    current &#x3D; tree-&gt;root;
    while (current !&#x3D; NULL) &#123;
        parent &#x3D; current;
        if (strcasecmp(id, current-&gt;key) &lt; 0)
            current &#x3D; current-&gt;left;
        else
            current &#x3D; current-&gt;right;
    &#125;

    &#x2F;&#x2F; Insert the new node as the left or right child of the parent
    if (strcasecmp(name, parent-&gt;key) &lt; 0)
        parent-&gt;left &#x3D; newNode;
    else
        parent-&gt;right &#x3D; newNode;

    newNode-&gt;parent &#x3D; parent;
&#125;</code></pre>
<ul>
<li>
<p><strong>Traverse the Tree</strong>:</p>
<ul>
<li>Start from the root (<code>tree-&gt;root</code>) and traverse the tree to find the correct position for the new node, based on its <code>id</code> (not <code>name</code>—this part seems incorrect, see below).</li>
</ul>
</li>
<li>
<p><strong>Comparison Logic</strong>:</p>
<ul>
<li>The <code>id</code> is compared to the <code>key</code> of the current node:</li>
<li>If <code>id</code> is smaller, traverse to the <strong>left child</strong>.</li>
<li>If <code>id</code> is larger, traverse to the <strong>right child</strong>.</li>
</ul>
</li>
<li>
<p><strong>Insert the Node</strong>:</p>
<ul>
<li>Once the correct parent node is found, the new node is inserted as the <strong>left</strong> or <strong>right child</strong> based on the comparison.</li>
</ul>
</li>
<li>
<p><strong>Set Parent</strong>:</p>
<ul>
<li>The <code>parent</code> pointer of the new node is updated to point to the node it was inserted under.</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Splay the New Node</li>
</ol>
<ul>
<li>After insertion, the <strong>splay operation</strong> is performed on the newly inserted node.</li>
<li>This ensures that the new node is moved to the root, maintaining the splay tree’s balancing property:
<ul>
<li>Recently accessed nodes are closer to the root, which optimizes subsequent accesses.</li>
</ul>
</li>
</ul>
<ol start="4">
<li>How <code>insert_splaytree</code>the Function Works
<ol>
<li>The tree performed pre-insertion search to check for duplicate nodes using the <code>id</code>.</li>
<li>If no duplicate exist and the tree is empty, the new node becomes the root.</li>
<li>Otherwise, the new node is inserted as a left or right child of its parent based on comparisons.</li>
<li>The new node is brought to the root of the tree by <strong>splaying</strong>, ensuring the splay tree’s efficiency for future operations.</li>
<li>If a duplicate <code>id</code> is found, the function exits with a message.</li>
</ol>
</li>
</ol>
<h4 id="Use-case-3-Delete">==Use case 3: Delete==</h4>
<p>The <code>delete_splaytree</code> function removes a node with the specified <code>key</code> from a <strong>splay tree</strong> while maintaining the tree’s structure and properties.</p>
<ol>
<li>Search for the Node to Delete<pre class="language-c" data-language="c"><code class="language-c">Node* current &#x3D; search_splaytree(tree, key, &quot;preorder&quot;);</code></pre>
</li>
</ol>
<ul>
<li>The function first searches for the node with the given <code>key</code> using a preorder traversal.</li>
<li>If the node is found (<code>current != NULL</code>), it proceeds with the deletion; otherwise, it prints an error message and exits.</li>
</ul>
<ol start="2">
<li>Splay the Node to the Root</li>
</ol>
<ul>
<li>Before deletion, the node to be deleted is splayed (brought to the root).</li>
<li>Splaying ensures that the deletion logic is simplified because the node is now the root.</li>
</ul>
<ol start="3">
<li>
<p>Handle the Three Cases of Deletion</p>
<ul>
<li>
<p>Case 1: Node Has No Children</p>
 <pre class="language-c" data-language="c"><code class="language-c">if (current-&gt;left &#x3D;&#x3D; NULL &amp;&amp; current-&gt;right &#x3D;&#x3D; NULL) &#123;
   tree-&gt;root &#x3D; NULL;
   free(current);
&#125;</code></pre>
<ul>
<li>If the node has no children, it is simply removed, and the root is set to <code>NULL</code>.</li>
</ul>
</li>
<li>
<p>Case 2: Node Has One Child</p>
  <pre class="language-c" data-language="c"><code class="language-c">else if (current-&gt;left &#x3D;&#x3D; NULL || current-&gt;right &#x3D;&#x3D; NULL) &#123;
    Node* child &#x3D; (current-&gt;left) ? current-&gt;left : current-&gt;right;
    if (current &#x3D;&#x3D; tree-&gt;root) &#123;
        tree-&gt;root &#x3D; child;
    &#125; else &#123;
        if (current &#x3D;&#x3D; current-&gt;parent-&gt;left)
            current-&gt;parent-&gt;left &#x3D; child;
        else
            current-&gt;parent-&gt;right &#x3D; child;

        child-&gt;parent &#x3D; current-&gt;parent;
    &#125;
    free(current);
&#125;</code></pre>
<ul>
<li>If the node has only one child:</li>
<li>The child replaces the node in the tree.</li>
<li>The child’s <code>parent</code> pointer is updated to point to the node’s parent.</li>
<li>If the node is the root, the child becomes the new root.</li>
</ul>
</li>
<li>
<p>Case 3: Node Has Two Children</p>
  <pre class="language-c" data-language="c"><code class="language-c">else &#123;
    Node* successor &#x3D; current-&gt;right;
    while (successor-&gt;left !&#x3D; NULL) &#123;
        successor &#x3D; successor-&gt;left;
    &#125;

    &#x2F;&#x2F; Replace current node&#39;s data with successor&#39;s data
    strcpy(current-&gt;key, successor-&gt;key);
    strcpy(current-&gt;name, successor-&gt;name);
    strcpy(current-&gt;class, successor-&gt;class);
    strcpy(current-&gt;record, successor-&gt;record);

    &#x2F;&#x2F; Successor will have at most one child (right child)
    Node* child &#x3D; successor-&gt;right;
    if (successor-&gt;parent-&gt;left &#x3D;&#x3D; successor)
        successor-&gt;parent-&gt;left &#x3D; child;
    else
        successor-&gt;parent-&gt;right &#x3D; child;

    if (child !&#x3D; NULL) 
        child-&gt;parent &#x3D; successor-&gt;parent;

    free(successor);
&#125;</code></pre>
</li>
<li>
<p>If the node has two children:</p>
<ul>
<li>The <strong>in-order successor</strong> (smallest node in the right subtree) is located.</li>
<li>The data from the successor node is copied to the current node.</li>
<li>The successor node is removed, which is simplified because it will have at most one child (right child).</li>
<li>If the successor has a right child, it replaces the successor in the tree.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>How <code>delete_splaytree</code> Function Works</p>
<ul>
<li>Searches for the node to delete.</li>
<li>Splays the node to bring it to the root.</li>
<li>Handles deletion based on the node’s number of children:
<ul>
<li>No children → Remove directly.</li>
<li>One child → Replace with the child.</li>
<li>Two children → Replace data with successor and remove the successor.</li>
</ul>
</li>
<li>Updates the tree structure to maintain validity after deletion.</li>
<li>Returns success or failure based on whether the node was found.</li>
</ul>
</li>
</ol>
<h3 id="2-2-System-Design">2.2 System Design</h3>
<p>Document the class diagram and algorithm design in pseudo code or flowchart<br>
Algorithm: Flowchart for each module</p>
<pre class="mermaid">graph TB
    subgraph file_handling
    input_txt_file--> B[read_file]
    I[append_contact]
    J[delete_contact]
    end
    subgraph splaytree_test
    B --> C[Stuct student_info<br>Node* node<br>Struct SplayTree]
    C --> D[read_argv]
    end
    subgraph splaytree_top
    D--search--> E[search_splaytree]
    D--insert--> F[insert_splaytree]
    F--search--> E
    D--delete--> G[delete_splaytree]
    G--search--> E
    end
    subgraph splaytree_bot
    E--> M[postorder_search]
    M--search/delete/insert--> H[splay]
    E--> K[inorder_search]
    K--search/delete/insert--> H
    E--> L[preorder_search]
    L--search/delete/insert--> H
    end
    H--insert--> I
    H--delete--> J</pre>
<h4 id="1-How-Splay-Trees-Algorithm-Work">==1. How Splay Trees Algorithm Work==</h4>
<p>A <strong>splay tree</strong> is a self-adjusting binary search tree that brings the most recently accessed node to the root through a process called <strong>splaying</strong>.</p>
<p>This adjustment improves the efficiency of subsequent operations on the same or nearby elements.</p>
<p>There is several key properties for splay tree algorithm:</p>
<ul>
<li>
<p><strong>Self-Adjusting</strong>:</p>
<ul>
<li>After any operation (search, insert, delete), the accessed node is splayed to the root.</li>
<li>This ensures that frequently accessed nodes are near the root, reducing access time for future operations.</li>
</ul>
</li>
<li>
<p><strong>Binary Search Tree (BST) Property</strong>:</p>
<ul>
<li>Like all binary search trees:
<ul>
<li>Nodes in the left subtree of a node have keys smaller than the node’s key.</li>
<li>Nodes in the right subtree have keys greater than the node’s key.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Amortized Efficiency</strong>:</p>
<ul>
<li>Although a single operation may take (O(n)) time in the worst case, the <strong>amortized cost</strong> of operations (over a sequence of operations) is (O(\log n)).</li>
</ul>
</li>
</ul>
<h4 id="2-Basic-Operations">==2. Basic Operations==</h4>
<p>The basic operations of a splay tree are:</p>
<ul>
<li><strong>Search</strong>: Find a node by key and bring it to the root.</li>
<li><strong>Insert</strong>: Add a new node to the tree and splay it to the root.</li>
<li><strong>Delete</strong>: Remove a node and reorganize the tree such that it remains valid, splaying the predecessor or successor of the deleted node to the root.</li>
</ul>
<h4 id="3-Splay-Tree-Rotation-Cases">==3. Splay Tree Rotation Cases==</h4>
<p>The <strong>splay operation</strong> is the core of splay trees. It rearranges the tree to bring a specified node (<code>x</code>) to the root using rotations. Splaying ensures that nodes accessed recently or frequently are near the root, optimizing access times.</p>
<p>The splay operation has different rotation cases that works by repeatedly applying one of the following rotations until the target node becomes the root.</p>
<p>The splay operation adjusts the tree structure by repeatedly performing rotations to bring a target node (<code>x</code>) to the root. These rotations ensure that frequently accessed nodes are closer to the root, improving future operation efficiency. Below are detailed explanations of the six possible rotation cases:</p>
<h5 id="a-Zig-Single-Right-Rotation">a. Zig (Single Right Rotation)</h5>
<ul>
<li>The target node (<code>x</code>) is the left child of its parent (<code>p</code>), and the parent has no grandparent (it is the root).</li>
</ul>
<pre class="language-none"><code class="language-none">Before Zig:
      p
     &#x2F;
    x

After Zig:
    x
     \
      p</code></pre>
<ul>
<li>Perform a single right rotation on the parent (<code>p</code>).</li>
<li>This makes the target node (<code>x</code>) the new root.</li>
<li>The height of the subtree decreases.</li>
<li>Used to splay nodes closer to the root in single-level trees.</li>
</ul>
<h5 id="b-Zag-Single-Left-Rotation">b. Zag (Single Left Rotation)</h5>
<ul>
<li>The target node (<code>x</code>) is the right child of its parent (<code>p</code>), and the parent has no grandparent (it is the root).</li>
</ul>
<pre class="language-none"><code class="language-none">Before Zag:
    p
     \
      x

After Zag:
      x
     &#x2F;
    p</code></pre>
<ul>
<li>Perform a single left rotation on the parent (<code>p</code>).</li>
<li>This makes the target node (<code>x</code>) the new root.</li>
<li>Similar to Zig, the subtree height decreases, and <code>x</code> becomes the root.</li>
</ul>
<h5 id="c-Zig-Zig-Double-Right-Rotation">c. Zig-Zig (Double Right Rotation)</h5>
<ul>
<li>The target node (<code>x</code>) is the left child of its parent (<code>p</code>), and the parent is also the left child of its grandparent (<code>g</code>).</li>
</ul>
<pre class="language-none"><code class="language-none">Before Zig-Zig:
        g
       &#x2F;
      p
     &#x2F;
    x

After Zig-Zig:
    x
     \
      p
       \
        g</code></pre>
<ul>
<li>Perform a right rotation on the grandparent (<code>g</code>).</li>
<li>Perform another right rotation on the parent (<code>p</code>).</li>
<li><code>x</code> is moved two levels closer to the root.</li>
<li>Reduces the height of the left-heavy subtree efficiently.</li>
</ul>
<h5 id="d-Zag-Zag-Double-Left-Rotation">d. Zag-Zag (Double Left Rotation)</h5>
<ul>
<li>The target node (<code>x</code>) is the right child of its parent (<code>p</code>), and the parent is also the right child of its grandparent (<code>g</code>).</li>
</ul>
<pre class="language-none"><code class="language-none">Before Zag-Zag:
    g
     \
      p
       \
        x

After Zag-Zag:
        x
       &#x2F;
      p
     &#x2F;
    g</code></pre>
<ul>
<li>Perform a left rotation on the grandparent (<code>g</code>).</li>
<li>Perform another left rotation on the parent (<code>p</code>).</li>
<li><code>x</code> is moved two levels closer to the root.</li>
<li>Balances right-heavy subtrees efficiently.</li>
</ul>
<h5 id="e-Zig-Zag-Right-Rotation-Followed-by-Left-Rotation">e. Zig-Zag (Right Rotation Followed by Left Rotation)</h5>
<ul>
<li>The target node (<code>x</code>) is the left child of its parent (<code>p</code>), and the parent is the right child of its grandparent (<code>g</code>).</li>
</ul>
<pre class="language-none"><code class="language-none">Before Zig-Zag:
        g
         \
          p
         &#x2F;
        x

After Zig-Zag:
        x
       &#x2F; \
      g   p</code></pre>
<ul>
<li>Perform a right rotation on the parent (<code>p</code>).</li>
<li>Perform a left rotation on the grandparent (<code>g</code>).</li>
<li><code>x</code> is moved two levels closer to the root.</li>
<li>Resolves imbalances caused by a “cross” relationship between parent and grandparent.</li>
</ul>
<h5 id="f-Zag-Zig-Left-Rotation-Followed-by-Right-Rotation">f. Zag-Zig (Left Rotation Followed by Right Rotation)</h5>
<ul>
<li>The target node (<code>x</code>) is the right child of its parent (<code>p</code>), and the parent is the left child of its grandparent (<code>g</code>).</li>
</ul>
<pre class="language-none"><code class="language-none">Before Zag-Zig:
        g
       &#x2F;
      p
       \
        x

After Zag-Zig:
        x
       &#x2F; \
      p   g</code></pre>
<ul>
<li>Perform a left rotation on the parent (<code>p</code>).</li>
<li>Perform a right rotation on the grandparent (<code>g</code>).</li>
<li>Similar to Zig-Zag, <code>x</code> is moved two levels closer to the root, resolving cross-relationship imbalances.</li>
</ul>
<p><strong>Summary of Rotations</strong></p>
<table>
<thead>
<tr>
<th><strong>Case</strong></th>
<th><strong>When?</strong></th>
<th><strong>Rotations Performed</strong></th>
<th><strong>Effect</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Zig</strong></td>
<td>Left child of the root</td>
<td>Single right rotation</td>
<td rowspan="2">Reduces height of subtree</td>
</tr>
<tr>
<td><strong>Zag</strong></td>
<td>Right child of the root</td>
<td>Single left rotation</td>
</tr>
<tr>
<td><strong>Zig-Zig</strong></td>
<td>Left child, parent is left child</td>
<td>Double right rotation</td>
<td>Balances left-heavy subtree</td>
</tr>
<tr>
<td><strong>Zag-Zag</strong></td>
<td>Right child, parent is right child</td>
<td>Double left rotation</td>
<td>Balances right-heavy subtree</td>
</tr>
<tr>
<td><strong>Zig-Zag</strong></td>
<td>Left child, parent is right child</td>
<td>Right + Left rotation</td>
<td rowspan="2">Resolves cross imbalances</td>
</tr>
<tr>
<td><strong>Zag-Zig</strong></td>
<td>Right child, parent is left child</td>
<td>Left + Right rotation</td>
</tr>
</tbody>
</table>
<p>Each rotation rebalances the tree while ensuring the target node moves closer to the root, maintaining efficient access patterns.</p>
<h4 id="4-Example-of-How-Splay-Tree-Works">==4. Example of How Splay Tree Works==</h4>
<h5 id="Initial-Tree">Initial Tree:</h5>
<pre class="language-none"><code class="language-none">    50
   &#x2F;  \
 30    70
 &#x2F; \
20  40</code></pre>
<h5 id="Search-for-Node-20"><strong>Search for Node 20:</strong></h5>
<p><strong>Locate Node 20</strong>:</p>
<ul>
<li>Traverse the tree: 50 → 30 → 20.</li>
</ul>
<p><strong>Splay Node 20 to Root</strong>:</p>
<ul>
<li>Step 1 (Zig-Zig): Rotate 30 with 50, then 20 with 30.</li>
</ul>
<h5 id="Final-Tree">Final Tree:</h5>
<pre class="language-none"><code class="language-none">20
  \
   30
     \
      50
     &#x2F;  \
   40    70</code></pre>
<h4 id="5-Advantages-of-Splay-Trees">==5. Advantages of Splay Trees==</h4>
<p><strong>Simple to Implement</strong>: No need for height or color maintenance (unlike AVL or Red-Black Trees).<br>
<strong>Adaptive Performance</strong>: Frequently accessed nodes are closer to the root, improving efficiency.<br>
<strong>Efficient Amortized Time Complexity</strong>: All operations (search, insert, delete) have an <strong>amortized cost</strong> of (O(\log n)).</p>
<h4 id="6-Limitations-of-Splay-Trees">==6. Limitations of Splay Trees==</h4>
<p><strong>Poor Worst-Case Performance</strong>: Individual operations can take (O(n)) time in degenerate cases (e.g., when the tree becomes unbalanced).<br>
<strong>No Guarantees for Balanced Trees</strong>: Unlike AVL or Red-Black Trees, splay trees do not ensure a balanced structure at all times.<br>
<strong>Not Optimal for Static Datasets</strong>: If access patterns are not skewed (i.e., no frequently accessed nodes), other self-balancing trees may perform better.</p>
<h4 id="7-Applications-of-Splay-Trees">==7. Applications of Splay Trees==</h4>
<p><strong>Caching and Memory Management</strong>: Frequently accessed data is brought closer to the root for fast retrieval.<br>
<strong>String Matching</strong>: Efficient implementation of operations on substrings (used in data compression).<br>
<strong>Dynamic Sets</strong>: Useful in scenarios where access patterns are skewed and frequently accessed elements dominate.</p>
<hr>
<h2 id="Part-3-System-Prototype">Part 3: System Prototype</h2>
<p>In this section, given the description of the system prototype. Provide the interface for each module</p>
<p><img src="/images/test_output.png" alt="images"><br>
<img src="/images/test_output1.png" alt="images1"></p>
<hr>
<h2 id="Part-4-Appendix">Part 4: Appendix</h2>
<p>List Of Data Files/File Output/ HardCopy of the source code</p>
<ul>
<li>Attached in the files</li>
</ul>
<hr>

</div>

<!-- post-guide -->

    <div class="post-guide">
        <div class="item left">
            
              <a href="/data_str_and_algo/adv-bin-search-tree/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  adv_bin_search_tree
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/computer_arch/Chap1-fundamental-quantitative-design-n-analysis/">
                Chap1_fundamental_quantitative_desigßn_n_analysis
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>


<!-- comment - giscus -->


<!-- comment - valine -->


<script>
	
	
</script>

	</div>
	<div id="footer">
	<p>
	©<span id="footerYear-start"></span>-<span id="footerYear-end"></span>

	
	    <a href="/">HuiWen</a>
	
	
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//wujun.me" target="_blank">Wu Jun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>


<script type="text/javascript">
	document.getElementById('footerYear-start').innerHTML = new Date().getFullYear() + '';
</script>

<script type="text/javascript">
	document.getElementById('footerYear-end').innerHTML = new Date().getFullYear() + '';
</script>

    <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
    <script>
      if (window.mermaid) {
        mermaid.initialize({theme: 'forest'});
      }
    </script>




	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>